"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[2634],{192:(n,e,t)=>{t.r(e),t.d(e,{default:()=>g});t(6540);var i=t(8774),o=t(1957),r=t(6025),a=t(4586),s=t(1432),l=t(4848),c=[{content:"Plug in new models, acquisition functions, and optimizers.",image:"img/puzzle_pieces.svg",title:"Modular"},{content:"Easily integrate neural network modules. Native GPU & autograd support.",image:"img/pytorch_logo.svg",title:"Built on PyTorch"},{content:"Support for scalable GPs via GPyTorch. Run code on multiple devices.",image:"img/expanding_arrows.svg",title:"Scalable"}],d=function(n){var e=n.imageUrl,t=n.title,i=n.content,o=n.image,a=(0,r.Ay)(e);return(0,l.jsxs)("div",{className:"col col--4 feature text--center",children:[a&&(0,l.jsx)("div",{children:(0,l.jsx)("img",{src:a,alt:t})}),o&&(0,l.jsx)("div",{children:(0,l.jsx)("img",{className:"margin--md",src:o,alt:t,style:{width:"80px",height:"80px"}})}),(0,l.jsx)("h2",{children:t}),(0,l.jsx)("p",{children:i})]})},m=function(){return(0,l.jsxs)("div",{className:"padding--xl",children:[(0,l.jsx)("h2",{className:"text--center padding--md",children:"Key Features"}),c&&c.length>0&&(0,l.jsx)("div",{className:"row",children:c.map((function(n){var e=n.title,t=n.imageUrl,i=n.content,o=n.image;return(0,l.jsx)(d,{title:e,imageUrl:t,content:i,image:o},e)}))})]})},h=function(){var n=(0,a.A)().siteConfig;return(0,l.jsxs)("div",{className:"homeContainer text--center",style:{height:"30rem"},children:[(0,l.jsxs)("div",{className:"padding-vert--md",children:[(0,l.jsx)("img",{src:(0,r.Ay)("img/botorch_logo_lockup_top.png"),alt:"Project Logo",style:{width:"300px"}}),(0,l.jsx)("p",{className:"hero__subtitle text--secondary margin-vert--md",children:n.tagline})]}),(0,l.jsxs)("div",{children:[(0,l.jsx)(i.A,{to:"/docs/introduction",className:"button button--lg button--outline button--secondary margin--sm",children:"Introduction"}),(0,l.jsx)(i.A,{to:"#quickstart",className:"button button--lg button--outline button--secondary margin--sm",children:"Get started"}),(0,l.jsx)(i.A,{to:"/docs/tutorials/",className:"button button--lg button--outline button--secondary margin--sm",children:"Tutorials"})]})]})};const g=function(){var n=(0,a.A)().siteConfig,e=function(){return(0,l.jsxs)("div",{className:"padding--xl",id:"quickstart",style:{"background-color":"var(--ifm-color-emphasis-100)"},children:[(0,l.jsx)("h2",{className:"text--center padding--md",children:"Get Started"}),(0,l.jsx)("div",{children:(0,l.jsxs)("ol",{children:[(0,l.jsxs)("li",{children:[(0,l.jsx)("h4",{children:"Install BoTorch:"}),"via pip (recommended):",(0,l.jsx)(s.A,{language:"bash",children:"pip install botorch"}),"via Anaconda (from the unofficial conda-forge channel):",(0,l.jsx)(s.A,{language:"bash",children:"conda install botorch -c gpytorch -c conda-forge"})]}),(0,l.jsxs)("li",{children:[(0,l.jsx)("h4",{children:"Fit a model:"}),(0,l.jsx)(s.A,{language:"python",children:"import torch\nfrom botorch.models import SingleTaskGP\nfrom botorch.models.transforms import Normalize, Standardize\nfrom botorch.fit import fit_gpytorch_mll\nfrom gpytorch.mlls import ExactMarginalLogLikelihood\n\ntrain_X = torch.rand(10, 2, dtype=torch.double) * 2\nY = 1 - torch.linalg.norm(train_X - 0.5, dim=-1, keepdim=True)\nY = Y + 0.1 * torch.randn_like(Y)  # add some noise\n\ngp = SingleTaskGP(\n  train_X=train_X,\n  train_Y=Y,\n  input_transform=Normalize(d=2),\n  outcome_transform=Standardize(m=1),\n)\nmll = ExactMarginalLogLikelihood(gp.likelihood, gp)\nfit_gpytorch_mll(mll)"})]}),(0,l.jsxs)("li",{children:[(0,l.jsx)("h4",{children:"Construct an acquisition function:"}),(0,l.jsx)(s.A,{language:"python",children:"from botorch.acquisition import LogExpectedImprovement\n\nlogEI = LogExpectedImprovement(model=gp, best_f=Y.max())"})]}),(0,l.jsxs)("li",{children:[(0,l.jsx)("h4",{children:"Optimize the acquisition function:"}),(0,l.jsx)(s.A,{language:"python",children:"from botorch.optim import optimize_acqf\n\nbounds = torch.stack([torch.zeros(2), torch.ones(2)]).to(torch.double)\ncandidate, acq_value = optimize_acqf(\n  logEI, bounds=bounds, q=1, num_restarts=5, raw_samples=20,\n)\ncandidate  # tensor([[0.2981, 0.2401]], dtype=torch.float64)"})]})]})})]})},t=function(){return(0,l.jsxs)("div",{className:"padding--lg",id:"reference",style:{},children:[(0,l.jsx)("h2",{className:"text--center",children:"References"}),(0,l.jsxs)("div",{children:[(0,l.jsx)("a",{href:"https://arxiv.org/abs/1910.06403",children:"BoTorch: A Framework for Efficient Monte-Carlo Bayesian Optimization"}),(0,l.jsx)(s.A,{className:"margin-vert--md",children:"@inproceedings{balandat2020botorch,\n  title = {{BoTorch: A Framework for Efficient Monte-Carlo Bayesian Optimization}},\n  author = {Balandat, Maximilian and Karrer, Brian and Jiang, Daniel R. and Daulton, Samuel and Letham, Benjamin and Wilson, Andrew Gordon and Bakshy, Eytan},\n  booktitle = {Advances in Neural Information Processing Systems 33},\n  year = 2020,\n  url = {http://arxiv.org/abs/1910.06403}\n}"}),"Check out some ",(0,l.jsx)("a",{href:"/docs/papers",children:"other papers using BoTorch"}),"."]})]})};return(0,l.jsxs)(o.A,{title:n.title,description:n.tagline,children:[(0,l.jsx)(h,{siteConfig:n}),(0,l.jsx)(m,{}),(0,l.jsx)(t,{}),(0,l.jsx)(e,{})]})}}}]);